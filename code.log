#version 330 core
out vec4 FragColor;

void main() {
    FragColor = vec4(0.1, 0.7, 0.6, 1.0);
}#version 330 core
layout(location = 0) in vec3 aPos;

uniform mat4 MVP;

void main() {
    gl_Position = MVP * vec4(aPos, 1.0);
}v -0.5 -0.5 -0.5
v  0.5 -0.5 -0.5
v  0.5  0.5 -0.5
v -0.5  0.5 -0.5
v -0.5 -0.5  0.5
v  0.5 -0.5  0.5
v  0.5  0.5  0.5
v -0.5  0.5  0.5

vt 0.0 0.0
vt 1.0 0.0
vt 1.0 1.0
vt 0.0 1.0

vn  0.0  0.0 -1.0
vn  0.0  0.0  1.0
vn -1.0  0.0  0.0
vn  1.0  0.0  0.0
vn  0.0 -1.0  0.0
vn  0.0  1.0  0.0
# front (-Z)

f 1/1/1 2/2/1 3/3/1
f 1/1/1 3/3/1 4/4/1
# back (+Z)

f 5/1/2 8/4/2 7/3/2
f 5/1/2 7/3/2 6/2/2
# left (-X)

f 1/1/3 4/4/3 8/3/3
f 1/1/3 8/3/3 5/2/3
# right (+X)

f 2/1/4 6/2/4 7/3/4
f 2/1/4 7/3/4 3/4/4
# bottom (-Y)

f 1/1/5 5/2/5 6/3/5
f 1/1/5 6/3/5 2/4/5
# top (+Y)

f 4/1/6 3/2/6 7/3/6
f 4/1/6 7/3/6 8/4/6#include "controller.hpp"
#include "defines.hpp"
#include <glm/ext/matrix_transform.hpp>
#include <glm/ext/vector_float2.hpp>
#include <glm/ext/vector_float3.hpp>
#include <glm/common.hpp>
#include <iostream>
#include <GL/glew.h>

void Controller::init(float speed)
{
    std::cout << "[*] Success to init controller!\n";
}

void Controller::controlFree(const bool* keyboardState, glm::mat4& view_, double delta,
                         float mouseX, float mouseY)
{
    direction.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw));
    direction.y = sin(glm::radians(pitch));
    direction.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));

    xoffset = mouseX * sensitivity * delta;
    yoffset = mouseY * sensitivity * delta;

    yaw   += xoffset;
    pitch -= yoffset;

    if (pitch >  89.0f)
        pitch =  89.0f;
    if (pitch < -89.0f)
        pitch = -89.0f;

    front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    front.y = sin(glm::radians(pitch));
    front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    front = glm::normalize(front);

    if (keyboardState[KEY_W])
        position += (float)delta * speed * front;
    if (keyboardState[KEY_S])
        position -= (float)delta * speed * front;
    if (keyboardState[KEY_A])
        position -= glm::normalize(glm::cross(front, up)) * (float)delta * speed;
    if (keyboardState[KEY_D])
        position += glm::normalize(glm::cross(front, up)) * (float)delta * speed;  
    if (keyboardState[KEY_LSHIFT])
        position.y -= speed * delta;
    if (keyboardState[KEY_SPACE])
        position.y += speed * delta;

    view_ = glm::lookAt(position, position + front, up);
}
#pragma once

#include <glm/ext/vector_float3.hpp>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <SDL3/SDL.h>

class Controller
{
public:
    void init(float speed);
    void controlFree(const bool* keyboardState, glm::mat4 &view_, double delta, float mouseX, float mouseY);
    
private:
    float speed = 5.0f;
    float pitch = 0.0f;
    float yaw = -90.0f;
    float sensitivity = 10.0f;
    float xoffset = 0.0f;
    float yoffset = 0.0f;
    glm::vec3 position = glm::vec3(0.0f, 0.5f, 3.0f);
    glm::vec3 front = glm::vec3(0.0f, 0.0f, -1.0f);
    glm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f);
    glm::vec3 direction = glm::vec3(0.0f, 0.0f, 0.0f);
    
};#include "defaultController.hpp"
#include <SDL3/SDL.h>
#include <iostream>
#include "defines.hpp"

void DController::init(float speed)
{
    yaw = 0.0f;
    std::cout << "[*] Success to init DController!\n";
}

void DController::controlFree(const bool* keyboardState, glm::mat4& view_, double delta,
                             float mouseX, float mouseY)
{
    float dt = (float)delta;

    xoffset = mouseX * sensitivity * dt;
    yoffset = mouseY * sensitivity * dt;

    yaw   += xoffset;
    pitch -= yoffset;

    if (pitch >  89.0f) pitch =  89.0f;
    if (pitch < -89.0f) pitch = -89.0f;

    front.x = cos(glm::radians(yaw)) * cos(glm::radians(pitch));
    front.y = sin(glm::radians(pitch));
    front.z = sin(glm::radians(yaw)) * cos(glm::radians(pitch));
    front = glm::normalize(front);

    glm::vec3 forwardXZ = glm::normalize(glm::vec3(front.x, 0.0f, front.z));
    glm::vec3 rightXZ = glm::normalize(glm::cross(forwardXZ, up));

    glm::vec3 moveDir(0.0f);
    if (keyboardState[KEY_W]) moveDir += forwardXZ;
    if (keyboardState[KEY_S]) moveDir -= forwardXZ;
    if (keyboardState[KEY_A]) moveDir -= rightXZ;
    if (keyboardState[KEY_D]) moveDir += rightXZ;

    if (glm::length(moveDir) > 0.0f)
    {
        moveDir = glm::normalize(moveDir);
        position += moveDir * speed * dt;
        if (bobEnabled)
            bobTimer += dt * bobFrequency * glm::length(moveDir);
    }

    if (keyboardState[KEY_SPACE] && !isJumping)
    {
        isJumping = true;
        velocityY = jumpSpeed;
    }

    if (isJumping)
    {
        velocityY += gravity * dt;
        position.y += velocityY * dt;
    }

    float baseEye = floorY + eyeHeight;
    if (position.y <= baseEye)
    {
        position.y = baseEye;
        isJumping = false;
        velocityY = 0.0f;
    }

    float bobOffset = 0.0f;
    if (bobEnabled && glm::length(moveDir) > 0.0f)
        bobOffset = sin(bobTimer * glm::two_pi<float>()) * bobAmplitude;

    glm::vec3 eyePos = position;
    eyePos.y += bobOffset;
    
    view_ = glm::lookAt(eyePos, eyePos + front, up);
}
#pragma once

#include <glm/ext/vector_float3.hpp>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <SDL3/SDL.h>

class DController
{
public:
    void init(float speed);
    void controlFree(const bool* keyboardState, glm::mat4 &view_, double delta, float mouseX, float mouseY);

private:
    float speed = 5.0f;
    float pitch = 0.0f;
    float yaw = -90.0f;
    float sensitivity = 10.0f;
    float xoffset = 0.0f;
    float yoffset = 0.0f;

    glm::vec3 position = glm::vec3(0.0f, 0.5f, 3.0f);
    glm::vec3 front = glm::vec3(0.0f, 0.0f, -1.0f);
    glm::vec3 up    = glm::vec3(0.0f, 1.0f, 0.0f);
    glm::vec3 direction = glm::vec3(0.0f, 0.0f, 0.0f);

    bool  bobEnabled = true;
    float bobAmplitude = 0.03f;
    float bobFrequency = 1.8f;
    float bobTimer = 0.0f;

    float floorY = 0.0f;
    float eyeHeight = 1.7f;

    bool  isJumping = false;
    float velocityY = 0.0f;
    float jumpSpeed = 4.5f;
    float gravity = -9.81f;
};
#pragma once

/* SDL_SCANCODE_<NAME> -> KEY_<NAME> */
#define KEY_UNKNOWN           SDL_SCANCODE_UNKNOWN
#define KEY_A                 SDL_SCANCODE_A
#define KEY_B                 SDL_SCANCODE_B
#define KEY_C                 SDL_SCANCODE_C
#define KEY_D                 SDL_SCANCODE_D
#define KEY_E                 SDL_SCANCODE_E
#define KEY_F                 SDL_SCANCODE_F
#define KEY_G                 SDL_SCANCODE_G
#define KEY_H                 SDL_SCANCODE_H
#define KEY_I                 SDL_SCANCODE_I
#define KEY_J                 SDL_SCANCODE_J
#define KEY_K                 SDL_SCANCODE_K
#define KEY_L                 SDL_SCANCODE_L
#define KEY_M                 SDL_SCANCODE_M
#define KEY_N                 SDL_SCANCODE_N
#define KEY_O                 SDL_SCANCODE_O
#define KEY_P                 SDL_SCANCODE_P
#define KEY_Q                 SDL_SCANCODE_Q
#define KEY_R                 SDL_SCANCODE_R
#define KEY_S                 SDL_SCANCODE_S
#define KEY_T                 SDL_SCANCODE_T
#define KEY_U                 SDL_SCANCODE_U
#define KEY_V                 SDL_SCANCODE_V
#define KEY_W                 SDL_SCANCODE_W
#define KEY_X                 SDL_SCANCODE_X
#define KEY_Y                 SDL_SCANCODE_Y
#define KEY_Z                 SDL_SCANCODE_Z

#define KEY_1                 SDL_SCANCODE_1
#define KEY_2                 SDL_SCANCODE_2
#define KEY_3                 SDL_SCANCODE_3
#define KEY_4                 SDL_SCANCODE_4
#define KEY_5                 SDL_SCANCODE_5
#define KEY_6                 SDL_SCANCODE_6
#define KEY_7                 SDL_SCANCODE_7
#define KEY_8                 SDL_SCANCODE_8
#define KEY_9                 SDL_SCANCODE_9
#define KEY_0                 SDL_SCANCODE_0

#define KEY_RETURN            SDL_SCANCODE_RETURN
#define KEY_ESCAPE            SDL_SCANCODE_ESCAPE
#define KEY_BACKSPACE         SDL_SCANCODE_BACKSPACE
#define KEY_TAB               SDL_SCANCODE_TAB
#define KEY_SPACE             SDL_SCANCODE_SPACE
#define KEY_MINUS             SDL_SCANCODE_MINUS
#define KEY_EQUALS            SDL_SCANCODE_EQUALS
#define KEY_LEFTBRACKET       SDL_SCANCODE_LEFTBRACKET
#define KEY_RIGHTBRACKET      SDL_SCANCODE_RIGHTBRACKET
#define KEY_BACKSLASH         SDL_SCANCODE_BACKSLASH
#define KEY_NONUSHASH         SDL_SCANCODE_NONUSHASH
#define KEY_SEMICOLON         SDL_SCANCODE_SEMICOLON
#define KEY_APOSTROPHE        SDL_SCANCODE_APOSTROPHE
#define KEY_GRAVE             SDL_SCANCODE_GRAVE
#define KEY_COMMA             SDL_SCANCODE_COMMA
#define KEY_PERIOD            SDL_SCANCODE_PERIOD
#define KEY_SLASH             SDL_SCANCODE_SLASH
#define KEY_CAPSLOCK          SDL_SCANCODE_CAPSLOCK

#define KEY_F1                SDL_SCANCODE_F1
#define KEY_F2                SDL_SCANCODE_F2
#define KEY_F3                SDL_SCANCODE_F3
#define KEY_F4                SDL_SCANCODE_F4
#define KEY_F5                SDL_SCANCODE_F5
#define KEY_F6                SDL_SCANCODE_F6
#define KEY_F7                SDL_SCANCODE_F7
#define KEY_F8                SDL_SCANCODE_F8
#define KEY_F9                SDL_SCANCODE_F9
#define KEY_F10               SDL_SCANCODE_F10
#define KEY_F11               SDL_SCANCODE_F11
#define KEY_F12               SDL_SCANCODE_F12

#define KEY_PRINTSCREEN       SDL_SCANCODE_PRINTSCREEN
#define KEY_SCROLLLOCK        SDL_SCANCODE_SCROLLLOCK
#define KEY_PAUSE             SDL_SCANCODE_PAUSE
#define KEY_INSERT            SDL_SCANCODE_INSERT
#define KEY_HOME              SDL_SCANCODE_HOME
#define KEY_PAGEUP            SDL_SCANCODE_PAGEUP
#define KEY_DELETE            SDL_SCANCODE_DELETE
#define KEY_END               SDL_SCANCODE_END
#define KEY_PAGEDOWN          SDL_SCANCODE_PAGEDOWN
#define KEY_RIGHT             SDL_SCANCODE_RIGHT
#define KEY_LEFT              SDL_SCANCODE_LEFT
#define KEY_DOWN              SDL_SCANCODE_DOWN
#define KEY_UP                SDL_SCANCODE_UP
#define KEY_RSHIFT            SDL_SCANCODE_RSHIFT
#define KEY_LSHIFT            SDL_SCANCODE_LSHIFT

#define KEY_NUMLOCKCLEAR      SDL_SCANCODE_NUMLOCKCLEAR
#define KEY_KP_DIVIDE         SDL_SCANCODE_KP_DIVIDE
#define KEY_KP_MULTIPLY       SDL_SCANCODE_KP_MULTIPLY
#define KEY_KP_MINUS          SDL_SCANCODE_KP_MINUS
#define KEY_KP_PLUS           SDL_SCANCODE_KP_PLUS
#define KEY_KP_ENTER          SDL_SCANCODE_KP_ENTER
#define KEY_KP_1              SDL_SCANCODE_KP_1
#define KEY_KP_2              SDL_SCANCODE_KP_2
#define KEY_KP_3              SDL_SCANCODE_KP_3
#define KEY_KP_4              SDL_SCANCODE_KP_4
#define KEY_KP_5              SDL_SCANCODE_KP_5
#define KEY_KP_6              SDL_SCANCODE_KP_6
#define KEY_KP_7              SDL_SCANCODE_KP_7
#define KEY_KP_8              SDL_SCANCODE_KP_8
#define KEY_KP_9              SDL_SCANCODE_KP_9
#define KEY_KP_0              SDL_SCANCODE_KP_0
#define KEY_KP_PERIOD         SDL_SCANCODE_KP_PERIOD

#define KEY_NONUSBACKSLASH    SDL_SCANCODE_NONUSBACKSLASH
#define KEY_APPLICATION       SDL_SCANCODE_APPLICATION
#define KEY_POWER             SDL_SCANCODE_POWER
#define KEY_KP_EQUALS         SDL_SCANCODE_KP_EQUALS
#define KEY_F13               SDL_SCANCODE_F13
#define KEY_F14               SDL_SCANCODE_F14
#define KEY_F15               SDL_SCANCODE_F15
#define KEY_F16               SDL_SCANCODE_F16
#define KEY_F17               SDL_SCANCODE_F17
#define KEY_F18               SDL_SCANCODE_F18
#define KEY_F19               SDL_SCANCODE_F19
#define KEY_F20               SDL_SCANCODE_F20
#define KEY_F21               SDL_SCANCODE_F21
#define KEY_F22               SDL_SCANCODE_F22
#define KEY_F23               SDL_SCANCODE_F23
#define KEY_F24               SDL_SCANCODE_F24

#define KEY_EXECUTE           SDL_SCANCODE_EXECUTE
#define KEY_HELP              SDL_SCANCODE_HELP
#define KEY_MENU              SDL_SCANCODE_MENU
#define KEY_SELECT            SDL_SCANCODE_SELECT
#define KEY_STOP              SDL_SCANCODE_STOP
#define KEY_AGAIN             SDL_SCANCODE_AGAIN
#define KEY_UNDO              SDL_SCANCODE_UNDO
#define KEY_CUT               SDL_SCANCODE_CUT
#define KEY_COPY              SDL_SCANCODE_COPY
#define KEY_PASTE             SDL_SCANCODE_PASTE
#define KEY_FIND              SDL_SCANCODE_FIND
#define KEY_MUTE              SDL_SCANCODE_MUTE
#define KEY_VOLUMEUP          SDL_SCANCODE_VOLUMEUP
#define KEY_VOLUMEDOWN        SDL_SCANCODE_VOLUMEDOWN

#define KEY_LOCKINGCAPSLOCK   SDL_SCANCODE_LOCKINGCAPSLOCK
#define KEY_LOCKINGNUMLOCK    SDL_SCANCODE_LOCKINGNUMLOCK
#define KEY_LOCKINGSCROLLLOCK SDL_SCANCODE_LOCKINGSCROLLLOCK

#define KEY_KP_COMMA          SDL_SCANCODE_KP_COMMA
#define KEY_KP_EQUALSAS400    SDL_SCANCODE_KP_EQUALSAS400

#define KEY_INTERNATIONAL1    SDL_SCANCODE_INTERNATIONAL1
#define KEY_INTERNATIONAL2    SDL_SCANCODE_INTERNATIONAL2
#define KEY_INTERNATIONAL3    SDL_SCANCODE_INTERNATIONAL3
#define KEY_INTERNATIONAL4    SDL_SCANCODE_INTERNATIONAL4
#define KEY_INTERNATIONAL5    SDL_SCANCODE_INTERNATIONAL5
#define KEY_INTERNATIONAL6    SDL_SCANCODE_INTERNATIONAL6
#define KEY_INTERNATIONAL7    SDL_SCANCODE_INTERNATIONAL7
#define KEY_INTERNATIONAL8    SDL_SCANCODE_INTERNATIONAL8
#define KEY_INTERNATIONAL9    SDL_SCANCODE_INTERNATIONAL9

#define KEY_LANG1             SDL_SCANCODE_LANG1
#define KEY_LANG2             SDL_SCANCODE_LANG2
#define KEY_LANG3             SDL_SCANCODE_LANG3
#define KEY_LANG4             SDL_SCANCODE_LANG4
#define KEY_LANG5             SDL_SCANCODE_LANG5
#define KEY_LANG6             SDL_SCANCODE_LANG6
#define KEY_LANG7             SDL_SCANCODE_LANG7
#define KEY_LANG8             SDL_SCANCODE_LANG8
#define KEY_LANG9             SDL_SCANCODE_LANG9

#define KEY_ALTERASE          SDL_SCANCODE_ALTERASE
#define KEY_SYSREQ            SDL_SCANCODE_SYSREQ
#define KEY_CANCEL            SDL_SCANCODE_CANCEL
#define KEY_CLEAR             SDL_SCANCODE_CLEAR
#define KEY_PRIOR             SDL_SCANCODE_PRIOR

#define KEY_RETURN2           SDL_SCANCODE_RETURN2
#define KEY_SEPARATOR         SDL_SCANCODE_SEPARATOR
#define KEY_OUT               SDL_SCANCODE_OUT
#define KEY_OPER              SDL_SCANCODE_OPER
#define KEY_CLEARAGAIN        SDL_SCANCODE_CLEARAGAIN
#define KEY_CRSEL             SDL_SCANCODE_CRSEL
#define KEY_EXSEL             SDL_SCANCODE_EXSEL

/* Клавиши мультимедиа и прочие расширенные */
#define KEY_AUDIONEXT         SDL_SCANCODE_AUDIONEXT
#define KEY_AUDIOPREV         SDL_SCANCODE_AUDIOPREV
#define KEY_AUDIOSTOP         SDL_SCANCODE_AUDIOSTOP
#define KEY_AUDIOPLAY         SDL_SCANCODE_AUDIOPLAY
#define KEY_AUDIOMUTE         SDL_SCANCODE_AUDIOMUTE
#define KEY_MEDIASELECT       SDL_SCANCODE_MEDIASELECT
#define KEY_WWW               SDL_SCANCODE_WWW
#define KEY_MAIL              SDL_SCANCODE_MAIL
#define KEY_CALCULATOR        SDL_SCANCODE_CALCULATOR
#define KEY_COMPUTER          SDL_SCANCODE_COMPUTER
#define KEY_AC_SEARCH         SDL_SCANCODE_AC_SEARCH
#define KEY_AC_HOME           SDL_SCANCODE_AC_HOME
#define KEY_AC_BACK           SDL_SCANCODE_AC_BACK
#define KEY_AC_FORWARD        SDL_SCANCODE_AC_FORWARD
#define KEY_AC_STOP           SDL_SCANCODE_AC_STOP
#define KEY_AC_REFRESH        SDL_SCANCODE_AC_REFRESH
#define KEY_AC_BOOKMARKS      SDL_SCANCODE_AC_BOOKMARKS

/* Игровые контроллеры и дополнительные F-keys до SDL_NUM_SCANCODES-1 */
#define KEY_BRIGHTNESSDOWN    SDL_SCANCODE_BRIGHTNESSDOWN
#define KEY_BRIGHTNESSUP      SDL_SCANCODE_BRIGHTNESSUP
#define KEY_DISPLAYSWITCH     SDL_SCANCODE_DISPLAYSWITCH
#define KEY_KBDILLUMTOGGLE    SDL_SCANCODE_KBDILLUMTOGGLE
#define KEY_KBDILLUMDOWN      SDL_SCANCODE_KBDILLUMDOWN
#define KEY_KBDILLUMUP        SDL_SCANCODE_KBDILLUMUP
#define KEY_EJECT             SDL_SCANCODE_EJECT
#define KEY_SLEEP             SDL_SCANCODE_SLEEP

#include "game.hpp"
#include <GL/glew.h>
#include <SDL3/SDL_events.h>
#include <SDL3/SDL_keyboard.h>
#include <SDL3/SDL_mouse.h>
#include <SDL3/SDL_oldnames.h>
#include <SDL3/SDL_render.h>
#include <SDL3/SDL_timer.h>
#include <SDL3/SDL_video.h>
#include <glm/ext/matrix_clip_space.hpp>
#include <glm/ext/matrix_transform.hpp>
#include <glm/trigonometric.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <string>
#include "defines.hpp"
#include <unordered_map>

void Game::run()
{
    init();
    mainLoop();
    cleanUp();
}

void Game::init()
{
    createWindow();
    initGLEW();
    initRender();
    matrixSetup();
    controller.init(2.0f);
    dController.init(2.0f);
    SDL_SetWindowRelativeMouseMode(window_, true);
}

void Game::mainLoop()
{
    Uint64 prev = SDL_GetPerformanceCounter();
    const double freq = (double)SDL_GetPerformanceFrequency();
    short count = 1000;
    
    while (running_)
    {
        while (SDL_PollEvent(&event_))
        {
            if (event_.type == SDL_EVENT_QUIT)
            {
                logger.message("Window is closed...");
                running_ = false;
            }

            if (event_.type == SDL_EVENT_MOUSE_MOTION)
            {
                mouseX = event_.motion.xrel;
                mouseY = event_.motion.yrel;
            }
        }

        // Get delta
        Uint64 now = SDL_GetPerformanceCounter();
        double delta = (now - prev) / freq;
        prev = now;

        // Get list of pressed keys
        const bool* keyboardState = SDL_GetKeyboardState(NULL);
        if (keyboardState[KEY_ESCAPE]) running_ = false;
        if (keyboardState[KEY_0]) controllerType = 0;
        if (keyboardState[KEY_1]) controllerType = 1;

        if (controllerType == 0)
            dController.controlFree(keyboardState, view, delta, mouseX, mouseY);
        else 
            controller.controlFree(keyboardState, view, delta, mouseX, mouseY);
        
        acceptMatrix();

        glClear(GL_COLOR_BUFFER_BIT);

        glBindVertexArray(VAO);
        shader.use();
        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);

        glBindVertexArray(cube.vao);
        glDrawElements(GL_TRIANGLES, (GLsizei)cube.idxCount, GL_UNSIGNED_INT, 0);
        glBindVertexArray(0);


        SDL_GL_SwapWindow(window_);
        SDL_Delay(16);

        mouseX = 0, mouseY = 0;
        if (count < 700)
        {
            int fps = 1.0 / delta;
            std::string fpsString = std::to_string(fps);
            fpsString = "Flame World: DEV (" + fpsString + ')'; 
            const char* fpsChar = fpsString.c_str();
            SDL_SetWindowTitle(window_, fpsChar);
            count = 1000;
        }   --count;
    }
}

void Game::cleanUp()
{
    SDL_SetWindowRelativeMouseMode(window_, false);
    if (window_) SDL_DestroyWindow(window_);
    if (glContext_) SDL_GL_DestroyContext(glContext_);
    if (SDL_INIT_STATUS_INITIALIZED) SDL_Quit();
}

void Game::createWindow()
{
    if (!SDL_Init(SDL_INIT_VIDEO))
    {
        logger.error("Failed to init the SDL3!");
        throw std::runtime_error(SDL_GetError());
    }   logger.message("Success to init the SDL3!");

    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 3);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);

    window_ = SDL_CreateWindow(
        "Flame World: Dev",
        windowWidth_,
        windowHeight_,
        SDL_WINDOW_OPENGL);
    if (!window_)
    {
        logger.error("Failed to create the window!");
        throw std::runtime_error(SDL_GetError());
    }   logger.message("Success to create the window!");

    glContext_ = SDL_GL_CreateContext(window_);
    if (!glContext_)
    {
        logger.error("Failed to create the OpenGL Context!");
        throw std::runtime_error(SDL_GetError());
    }   logger.message("Success to create the OpenGL Context!");

    SDL_GL_MakeCurrent(window_, glContext_);
}

void Game::initGLEW()
{
    glewExperimental = GL_TRUE;
    GLenum glewStatus = glewInit();
    if (glewStatus != GLEW_OK)
    {
        logger.error("Failed to init the GLEW!");
        const GLubyte* err = glewGetErrorString(glewStatus);
        throw std::runtime_error(reinterpret_cast<const char*>(glewGetErrorString(glewStatus)));
    }   logger.message("Success to init the GLEW!");
}

void Game::initRender()
{
    glGenVertexArrays(1, &VAO);
    glGenBuffers(1, &VBO);
    glBindVertexArray(VAO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, plane.size() * sizeof(GLfloat), plane.data(), GL_STATIC_DRAW);

    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0); 

    shader.loadSources("vertex.glsl", "fragment.glsl");
    shader.compile();
    shader.link();

    if (!loadObjCreateGL("./assets/cube.obj", cube))
    {
        std::cerr << "[!] Failed to load obj file. cube\n";
    }

    glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
}

void Game::matrixSetup()
{
    model = glm::mat4(1.0f);
    
    projection = glm::perspective(
        glm::radians(45.0f),
        (float)windowWidth_ / (float)windowHeight_,
        0.1f, 100.0f);

    MVP = projection * view * model;

    MVP_LOC = glGetUniformLocation(shader.getID(), "MVP");
}

void Game::acceptMatrix()
{
    MVP = projection * view * model;

    shader.use();
    glUniformMatrix4fv(MVP_LOC, 1, GL_FALSE, glm::value_ptr(MVP));
}

bool Game::loadObjCreateGL(const char* path, MeshGL &out)
{
    tinyobj::attrib_t attrib;
        std::vector<tinyobj::shape_t> shapes;
        std::vector<tinyobj::material_t> materials;
        std::string warn, err;
        if(!tinyobj::LoadObj(&attrib, &shapes, &materials, &warn, &err, path)) return false;

        struct V { float px,py,pz; float nx,ny,nz; float u,v; };
        std::vector<V> verts;
        std::vector<uint32_t> inds;
        verts.reserve(256); inds.reserve(256);
        std::unordered_map<uint64_t,uint32_t> dedup;
        dedup.reserve(256);

        auto pack = [](int a,int b,int c)->uint64_t{
            return (uint64_t(uint32_t(a))<<32) | (uint64_t(uint16_t(b&0xFFFF))<<16) | uint64_t(uint16_t(c&0xFFFF));
        };

        for(const auto &shape: shapes){
            for(const auto &idx: shape.mesh.indices){
                uint64_t key = pack(idx.vertex_index, idx.normal_index+1, idx.texcoord_index+1);
                auto it = dedup.find(key);
                if(it!=dedup.end()){ inds.push_back(it->second); continue; }
                V v{};
                int vi = idx.vertex_index*3;
                v.px = attrib.vertices[vi+0]; v.py = attrib.vertices[vi+1]; v.pz = attrib.vertices[vi+2];
                if(idx.normal_index>=0){ int ni=idx.normal_index*3; v.nx=attrib.normals[ni+0]; v.ny=attrib.normals[ni+1]; v.nz=attrib.normals[ni+2]; } else { v.nx=0; v.ny=0; v.nz=1; }
                if(idx.texcoord_index>=0){ int ti=idx.texcoord_index*2; v.u=attrib.texcoords[ti+0]; v.v=attrib.texcoords[ti+1]; } else { v.u=0; v.v=0; }
                uint32_t newIdx = (uint32_t)verts.size();
                verts.push_back(v);
                dedup.emplace(key,newIdx);
                inds.push_back(newIdx);
            }
        }

        if(out.vao==0) glGenVertexArrays(1, &out.vao);
        if(out.vbo==0)  glGenBuffers(1, &out.vbo);
        if(out.ebo==0)  glGenBuffers(1, &out.ebo);

        glBindVertexArray(out.vao);
        glBindBuffer(GL_ARRAY_BUFFER, out.vbo);
        glBufferData(GL_ARRAY_BUFFER, verts.size()*sizeof(V), verts.data(), GL_STATIC_DRAW);
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, out.ebo);
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, inds.size()*sizeof(uint32_t), inds.data(), GL_STATIC_DRAW);

        GLsizei stride = sizeof(V);
        glEnableVertexAttribArray(0); glVertexAttribPointer(0,3,GL_FLOAT,GL_FALSE,stride,(void*)offsetof(V,px));
        glEnableVertexAttribArray(1); glVertexAttribPointer(1,3,GL_FLOAT,GL_FALSE,stride,(void*)offsetof(V,nx));
        glEnableVertexAttribArray(2); glVertexAttribPointer(2,2,GL_FLOAT,GL_FALSE,stride,(void*)offsetof(V,u));

        glBindVertexArray(0);
        out.idxCount = (GLsizei)inds.size();
        return true;
}#pragma once

#include <SDL3/SDL.h>
#include <SDL3/SDL_rect.h>
#include <SDL3/SDL_render.h>
#include <vector>
#include <GL/glew.h>
#include "logger.hpp"
#include "shader.hpp"
#include "controller.hpp"
#include "defaultController.hpp"
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include <tiny_obj_loader.h>

class Game
{
public:
    void run();    
    
private:
    int windowWidth_ = 900;
    int windowHeight_ = 600;
    SDL_Window* window_;
    SDL_GLContext glContext_;
    SDL_Event event_;
    bool running_ = true;

    Logger logger;

    void init();
    void mainLoop();
    void cleanUp();

    void createWindow();
    void initGLEW();
    void initRender();

    GLuint VAO, VBO;
    
    std::vector<float> plane = {
        -1.0f, -1.0f, -1.0f,
        1.0f, -1.0f, -1.0f,
        1.0f, -1.0f, 1.0f,
        -1.0f, -1.0f, 1.0f,
    };

    Shader shader;
    glm::mat4 MVP;
    glm::mat4 model, view, projection;

    GLuint MVP_LOC;

    void matrixSetup();
    void acceptMatrix();

    bool controllerType = 0; // 0 - DController. 1 - Controller
    Controller controller;
    DController dController;

    float mouseX = 0.0f, mouseY = 0.0f;

    struct MeshGL { GLuint vao=0, vbo=0, ebo=0; GLsizei idxCount=0; };

    bool loadObjCreateGL(const char* path, MeshGL &out);

    MeshGL cube;

};#pragma once

#include <iostream>

class Logger
{
public:
    inline void message(const char* msg_) {
        std::cout << "[*] " << msg_ << std::endl;
    }

    inline void error(const char* msg_) {
        std::cout << "[!] " << msg_ << '\n' << "Aborting..." << std::endl;
    }
};#include "game.hpp"
#include <exception>
#include <iostream>

#define TINYOBJLOADER_IMPLEMENTATION

int main()
{
    Game game;

    try {
        game.run();
    } catch (std::exception& error_)
    {
        std::cout << error_.what() << std::endl;
        return 1;
    }

    return 0;
}#include "shader.hpp"

#include <fstream>
#include <sstream>
#include <stdexcept>
#include <vector>

Shader::Shader(const char* vertexPath, const char* fragmentPath) {
    if (vertexPath && fragmentPath) loadSources(vertexPath, fragmentPath);
}

Shader::~Shader() {
    if (program) glDeleteProgram(program);
    deleteShaders();
}

void Shader::loadSources(const char* vertexPath, const char* fragmentPath) {
    vertexShaderSource = readFileToString(vertexPath);
    fragmentShaderSource = readFileToString(fragmentPath);
}

std::string Shader::readFileToString(const char* path) {
    std::ifstream ifs(path);
    if (!ifs) {
        throw std::runtime_error(std::string("Failed to open shader file: ") + (path ? path : "null"));
    }
    std::ostringstream ss;
    ss << ifs.rdbuf();
    return ss.str();
}

void Shader::compile() {
    deleteShaders();

    if (vertexShaderSource.empty() || fragmentShaderSource.empty())
        throw std::runtime_error("Shader source is empty. Call loadSources() first.");

    auto compile_one = [](GLenum type, const std::string& src) -> GLuint {
        GLuint s = glCreateShader(type);
        const char* cstr = src.c_str();
        glShaderSource(s, 1, &cstr, nullptr);
        glCompileShader(s);
        return s;
    };

    vertexShader = compile_one(GL_VERTEX_SHADER, vertexShaderSource);
    checkCompileErrors(vertexShader, "VERTEX");

    fragmentShader = compile_one(GL_FRAGMENT_SHADER, fragmentShaderSource);
    checkCompileErrors(fragmentShader, "FRAGMENT");
}

void Shader::link() {
    if (!vertexShader || !fragmentShader)
        throw std::runtime_error("Shaders not compiled before linking.");

    if (program) {
        glDeleteProgram(program);
        program = 0;
    }

    program = glCreateProgram();
    glAttachShader(program, vertexShader);
    glAttachShader(program, fragmentShader);
    glLinkProgram(program);

    GLint success = 0;
    glGetProgramiv(program, GL_LINK_STATUS, &success);
    if (!success) {
        GLint len = 0;
        glGetProgramiv(program, GL_INFO_LOG_LENGTH, &len);
        std::vector<char> log(len > 0 ? len : 1);
        glGetProgramInfoLog(program, len, nullptr, log.data());
        std::string msg = "Program link error: " + std::string(log.data());
        glDeleteProgram(program);
        program = 0;
        throw std::runtime_error(msg);
    }

    deleteShaders();
}

void Shader::use() const {
    if (!program) throw std::runtime_error("Shader program not linked.");
    glUseProgram(program);
}

GLuint Shader::getID() const {
    return program;
}

void Shader::deleteShaders() noexcept {
    if (vertexShader) {
        glDeleteShader(vertexShader);
        vertexShader = 0;
    }
    if (fragmentShader) {
        glDeleteShader(fragmentShader);
        fragmentShader = 0;
    }
}

void Shader::checkCompileErrors(GLuint id, const std::string& type) {
    GLint success = 0;
    glGetShaderiv(id, GL_COMPILE_STATUS, &success);
    if (!success) {
        GLint len = 0;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &len);
        std::vector<char> log(len > 0 ? len : 1);
        glGetShaderInfoLog(id, len, nullptr, log.data());
        std::string msg = type + " shader compile error: " + std::string(log.data());
        glDeleteShader(id);
        throw std::runtime_error(msg);
    }
}

Shader::Shader(Shader&& o) noexcept
    : vertexShaderSource(std::move(o.vertexShaderSource)),
      fragmentShaderSource(std::move(o.fragmentShaderSource)),
      vertexShader(o.vertexShader),
      fragmentShader(o.fragmentShader),
      program(o.program)
{
    o.vertexShader = o.fragmentShader = o.program = 0;
}

Shader& Shader::operator=(Shader&& o) noexcept {
    if (this != &o) {
        if (program) glDeleteProgram(program);
        deleteShaders();

        vertexShaderSource = std::move(o.vertexShaderSource);
        fragmentShaderSource = std::move(o.fragmentShaderSource);
        vertexShader = o.vertexShader;
        fragmentShader = o.fragmentShader;
        program = o.program;

        o.vertexShader = o.fragmentShader = o.program = 0;
    }
    return *this;
}
#pragma once

#include <string>
#include <GL/glew.h>

class Shader
{
public:
    Shader() = default;
    explicit Shader(const char* vertexPath, const char* fragmentPath);
    ~Shader();

    void loadSources(const char* vertexPath, const char* fragmentPath);
    void compile();
    void link();
    void use() const;
    GLuint getID() const;
    Shader(const Shader&) = delete;
    Shader& operator=(const Shader&) = delete;
    Shader(Shader&&) noexcept;
    Shader& operator=(Shader&&) noexcept;

private:
    std::string vertexShaderSource;
    std::string fragmentShaderSource;

    GLuint vertexShader = 0;
    GLuint fragmentShader = 0;
    GLuint program = 0;

    void deleteShaders() noexcept;
    static void checkCompileErrors(GLuint id, const std::string& type);
    static std::string readFileToString(const char* path);
};
